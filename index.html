<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Senior Node Roadmap</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- React CDN -->
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>

  <!-- Babel to run JSX directly -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body style="margin:0">
  <div id="root"></div>

  <script type="text/babel">
    const { useState } = React;

    // Paste ONLY roadmapData + ProgressBar + SeniorNodeRoadmap here
    // (remove import/export lines)

    // ----------------------------
    // YOUR COMPONENT CODE START
    // ----------------------------

    // paste your roadmapData here
    // paste ProgressBar
    // paste SeniorNodeRoadmap
    // BUT remove:
    // import { useState } from "react";
    // export default

    import { useState } from "react";

const roadmapData = [
  {
    id: "phase1",
    phase: "Phase 1",
    title: "Node.js Internals & Advanced Concepts",
    duration: "4â€“6 weeks",
    icon: "âš™ï¸",
    color: "#0f766e",
    bgLight: "#f0fdfa",
    topics: [
      {
        name: "Event Loop Deep Dive",
        subtopics: [
          "Call stack, microtask queue, macrotask queue",
          "Phases: timers â†’ pending callbacks â†’ idle/prepare â†’ poll â†’ check â†’ close",
          "process.nextTick() vs setImmediate() vs Promise.resolve()",
          "Starvation scenarios and how to avoid them",
        ],
        theory: "The event loop is Node's heartbeat. Unlike browsers, Node's event loop has 6 distinct phases managed by libuv. Understanding execution order is what separates senior devs from juniors. Key insight: microtasks (Promise, nextTick) drain completely between each phase, which can starve I/O if abused.",
      },
      {
        name: "V8 Engine Internals",
        subtopics: [
          "JIT compilation: Ignition (interpreter) â†’ TurboFan (optimizing compiler)",
          "Hidden classes & inline caching â€” why object shape matters",
          "Garbage collection: Scavenger (young gen) & Mark-Sweep-Compact (old gen)",
          "Memory leaks: closures, event listeners, global refs, detached DOM",
        ],
        theory: "V8 compiles JS to machine code in two stages. Ignition generates bytecode fast; TurboFan optimizes hot functions. Hidden classes are internal type descriptors â€” adding properties in different orders creates different hidden classes, killing inline cache hits. For GC, young generation uses semi-space copying (Scavenger), old generation uses Mark-Sweep-Compact.",
      },
      {
        name: "Streams & Buffers",
        subtopics: [
          "Readable, Writable, Duplex, Transform streams",
          "Backpressure: highWaterMark, drain event, pipe() mechanics",
          "Buffer vs TypedArray, encoding strategies",
          "Building custom Transform streams for data pipelines",
        ],
        theory: "Streams process data in chunks instead of loading everything into memory. Backpressure is the mechanism where a slow consumer tells a fast producer to pause. When write() returns false, you must wait for 'drain'. pipe() handles this automatically. This is critical for file processing, HTTP responses, and any large data handling.",
      },
      {
        name: "Worker Threads & Cluster Module",
        subtopics: [
          "When to use: CPU-bound tasks (crypto, image processing, parsing)",
          "SharedArrayBuffer & Atomics for shared memory",
          "Cluster module: fork() strategy, sticky sessions, graceful restart",
          "Worker pool pattern with workerpool or piscina",
        ],
        theory: "Node is single-threaded for JS execution but uses a thread pool (libuv) for I/O. Worker threads give you true parallelism for CPU-bound work. Cluster module forks the entire process (separate V8 instances, separate memory). Use worker threads for computation, cluster for scaling HTTP servers across CPU cores.",
      },
      {
        name: "Advanced Async Patterns",
        subtopics: [
          "AsyncLocalStorage for request-scoped context (tracing, auth)",
          "AbortController for cancellable async operations",
          "async iterators & for-await-of for streaming data",
          "Error handling: unhandledRejection, uncaughtException strategies",
        ],
        theory: "AsyncLocalStorage (async_hooks) lets you propagate context through async call chains without passing it manually â€” essential for request tracing and logging. AbortController (from Web API, now in Node) lets you cancel fetch, timers, and custom async work. Async iterators turn any data source into a consumable async stream.",
      },
      {
        name: "Module System Deep Dive",
        subtopics: [
          "CommonJS: require resolution algorithm, circular dependency handling",
          "ESM: static analysis, top-level await, import.meta",
          "Dual-package publishing (CJS + ESM)",
          "Module caching, hot reloading strategies",
        ],
        theory: "CJS is synchronous and dynamically resolved at runtime. ESM is statically analyzable (enables tree-shaking) and asynchronous. CJS handles circular deps by returning a partial export object; ESM uses live bindings. For libraries, dual-package publishing via 'exports' field in package.json is now the standard.",
      },
    ],
  },
  {
    id: "phase2",
    phase: "Phase 2",
    title: "System Design & Architecture",
    duration: "5â€“7 weeks",
    icon: "ðŸ—ï¸",
    color: "#7c3aed",
    bgLight: "#f5f3ff",
    topics: [
      {
        name: "Design Patterns in Node.js",
        subtopics: [
          "Singleton (DB connections, config), Factory (object creation)",
          "Strategy pattern for swappable algorithms",
          "Observer/EventEmitter for decoupled communication",
          "Middleware pattern (Express/Koa), Chain of Responsibility",
          "Repository pattern for data access abstraction",
          "Dependency Injection (manual & with frameworks like tsyringe/InversifyJS)",
        ],
        theory: "Patterns aren't academic â€” they solve real problems. Singleton ensures one DB pool. Factory decouples object creation from usage. Strategy lets you swap auth methods (JWT, OAuth, API key) without changing controllers. Repository abstracts data access so you can swap Postgres for Mongo without touching business logic. DI makes everything testable.",
      },
      {
        name: "API Design",
        subtopics: [
          "REST maturity model (Richardson), HATEOAS in practice",
          "GraphQL: schema design, N+1 problem, DataLoader batching",
          "gRPC: Protocol Buffers, bidirectional streaming, when to use",
          "API versioning strategies (URL, header, content negotiation)",
          "Rate limiting, pagination (cursor vs offset), filtering patterns",
        ],
        theory: "REST is resource-oriented; GraphQL is query-oriented; gRPC is contract-oriented. REST excels for CRUD and cacheability. GraphQL solves over/under-fetching but introduces complexity (N+1 queries solved by DataLoader). gRPC shines for internal microservice communication with its binary protocol and streaming. A senior dev picks the right tool per use case.",
      },
      {
        name: "Microservices Architecture",
        subtopics: [
          "Service boundaries: Domain-Driven Design (bounded contexts)",
          "Communication: sync (REST/gRPC) vs async (message queues)",
          "Saga pattern for distributed transactions",
          "Service discovery, API gateway pattern",
          "Circuit breaker, bulkhead, retry with exponential backoff",
        ],
        theory: "Microservices aren't inherently better â€” they trade code complexity for operational complexity. Bounded contexts from DDD help you draw service boundaries correctly. Use synchronous communication for queries, asynchronous (RabbitMQ, Kafka) for commands. The Saga pattern replaces distributed transactions with a sequence of local transactions + compensating actions.",
      },
      {
        name: "Event-Driven Architecture",
        subtopics: [
          "Event sourcing: storing events as source of truth",
          "CQRS: separate read and write models",
          "Message brokers: RabbitMQ (task queues) vs Kafka (event streaming)",
          "Idempotency keys for exactly-once processing",
          "Dead letter queues and retry strategies",
        ],
        theory: "Event sourcing stores every state change as an immutable event â€” you derive current state by replaying events. CQRS separates read models (optimized for queries) from write models (optimized for commands). Together, they enable scalable, auditable systems. Kafka is ideal for high-throughput event streaming; RabbitMQ for traditional task distribution.",
      },
      {
        name: "Authentication & Security",
        subtopics: [
          "JWT deep dive: signing algorithms, refresh token rotation",
          "OAuth 2.0 / OpenID Connect flows (authorization code + PKCE)",
          "OWASP Top 10: injection, XSS, CSRF, SSRF prevention",
          "Rate limiting, helmet.js, CORS, CSP headers",
          "Secrets management (Vault, env vars, KMS)",
        ],
        theory: "JWTs are stateless but can't be revoked easily â€” use short-lived access tokens with refresh token rotation. OAuth 2.0 delegates authentication; PKCE prevents authorization code interception. For security, think in layers: input validation (Joi/Zod), parameterized queries, CSP headers, rate limiting, and always hash passwords with bcrypt/argon2.",
      },
      {
        name: "Scalability Patterns",
        subtopics: [
          "Horizontal vs vertical scaling",
          "Caching layers: in-memory (LRU), Redis, CDN",
          "Load balancing: round-robin, least connections, consistent hashing",
          "Database sharding & read replicas",
          "Stateless services and session externalization",
        ],
        theory: "Horizontal scaling (more machines) beats vertical (bigger machine) for resilience. Cache at every layer: application (LRU), distributed (Redis), edge (CDN). Stateless services are key â€” externalize sessions to Redis so any instance can handle any request. Consistent hashing distributes load while minimizing redistribution when nodes join/leave.",
      },
    ],
  },
  {
    id: "phase3",
    phase: "Phase 3",
    title: "Databases & ORMs",
    duration: "4â€“5 weeks",
    icon: "ðŸ—„ï¸",
    color: "#c2410c",
    bgLight: "#fff7ed",
    topics: [
      {
        name: "PostgreSQL Advanced",
        subtopics: [
          "Query planning: EXPLAIN ANALYZE, index types (B-tree, GIN, GiST, BRIN)",
          "Transactions: ACID, isolation levels, deadlock detection",
          "Connection pooling (PgBouncer, built-in pool)",
          "Partitioning, materialized views, CTEs, window functions",
          "JSONB for semi-structured data alongside relational data",
        ],
        theory: "PostgreSQL is the go-to for relational workloads. EXPLAIN ANALYZE shows actual execution plans â€” look for sequential scans on large tables (add indexes). B-tree for equality/range, GIN for full-text/JSONB, BRIN for naturally ordered data. Connection pooling is critical in Node because each connection is expensive (~10MB RAM). Use PgBouncer in transaction mode for microservices.",
      },
      {
        name: "MongoDB Advanced",
        subtopics: [
          "Aggregation pipeline (match, group, lookup, unwind)",
          "Indexing strategies: compound, text, TTL, partial indexes",
          "Schema design: embedding vs referencing decision framework",
          "Transactions in replica sets, read/write concerns",
          "Change streams for real-time data pipelines",
        ],
        theory: "MongoDB's strength is flexible schema and horizontal scaling via sharding. Embed data that's read together; reference data that changes independently or grows unboundedly. The aggregation pipeline is MongoDB's SQL â€” learn it deeply. Change streams let you react to data changes in real-time (great for syncing caches, triggering workflows).",
      },
      {
        name: "Redis Beyond Caching",
        subtopics: [
          "Data structures: Strings, Hashes, Sets, Sorted Sets, Streams",
          "Pub/Sub for real-time messaging",
          "Redis Streams for event streaming (consumer groups)",
          "Lua scripting for atomic operations",
          "Redis as session store, rate limiter, distributed lock (Redlock)",
        ],
        theory: "Redis isn't just a cache â€” it's a data structure server. Sorted Sets power leaderboards and priority queues. Redis Streams is a log-based structure similar to Kafka (with consumer groups). Redlock implements distributed locks across Redis instances. Lua scripts execute atomically on the server â€” use for read-modify-write operations that need atomicity.",
      },
      {
        name: "ORMs & Query Builders",
        subtopics: [
          "Prisma: schema-first, type-safe queries, migrations",
          "TypeORM: decorator-based, Active Record & Data Mapper patterns",
          "Knex.js: query builder for full SQL control",
          "When to use raw SQL vs ORM (complex queries, performance)",
          "Migration strategies for zero-downtime deploys",
        ],
        theory: "Prisma is the modern choice â€” schema-first approach generates type-safe client code. TypeORM is more traditional (similar to Hibernate/ActiveRecord). Knex.js gives you a query builder without the full ORM abstraction. Senior devs know when to drop to raw SQL: complex joins, CTEs, window functions, or performance-critical queries. Always use migrations, never manual schema changes.",
      },
      {
        name: "Data Modeling & Patterns",
        subtopics: [
          "Normalization (1NFâ€“3NF) vs strategic denormalization",
          "Soft deletes, audit trails, temporal tables",
          "Multi-tenancy: schema-per-tenant, row-level, DB-per-tenant",
          "Polyglot persistence: right DB for the right job",
        ],
        theory: "Normalize first, denormalize for performance. Soft deletes (deleted_at column) keep data recoverable but complicate queries â€” use database views to abstract. Multi-tenancy choice depends on scale: row-level is simplest, schema-per-tenant balances isolation and cost, DB-per-tenant gives maximum isolation. Polyglot persistence means using Postgres for transactions, Redis for caching, Elasticsearch for search â€” each DB for its strength.",
      },
    ],
  },
  {
    id: "phase4",
    phase: "Phase 4",
    title: "DevOps, CI/CD & Cloud",
    duration: "4â€“5 weeks",
    icon: "â˜ï¸",
    color: "#1d4ed8",
    bgLight: "#eff6ff",
    topics: [
      {
        name: "Docker & Containerization",
        subtopics: [
          "Multi-stage builds for minimal Node.js images",
          "Layer caching optimization (COPY package*.json first)",
          "Docker Compose for local dev environments",
          "Security: non-root user, .dockerignore, minimal base images (alpine/distroless)",
          "Health checks, graceful shutdown (SIGTERM handling)",
        ],
        theory: "Multi-stage builds separate build dependencies from runtime â€” your final image should only contain production code and node_modules. Copy package.json before source code so npm install is cached when only code changes. Always run as non-root user. Handle SIGTERM for graceful shutdown: close server, finish in-flight requests, close DB connections, then exit.",
      },
      {
        name: "CI/CD Pipelines",
        subtopics: [
          "GitHub Actions / GitLab CI pipeline design",
          "Testing stages: lint â†’ unit â†’ integration â†’ e2e",
          "Automated versioning (semantic-release, conventional commits)",
          "Container registry push, image scanning (Trivy/Snyk)",
          "Deployment strategies: blue-green, canary, rolling",
        ],
        theory: "A good pipeline catches issues early and deploys confidently. Lint first (fastest feedback), then unit tests, then integration tests against real services (Docker Compose), then e2e. Blue-green deploys maintain two identical environments and switch traffic instantly. Canary deploys route a small percentage to the new version first. Both enable zero-downtime releases and fast rollback.",
      },
      {
        name: "Kubernetes Essentials",
        subtopics: [
          "Pods, Deployments, Services, Ingress",
          "ConfigMaps & Secrets for configuration",
          "Horizontal Pod Autoscaler (HPA) based on CPU/memory/custom metrics",
          "Liveness & readiness probes for Node.js apps",
          "Helm charts for packaging applications",
        ],
        theory: "Kubernetes orchestrates containers at scale. Pods are the smallest unit (usually one container). Deployments manage replica sets and rolling updates. Services provide stable networking. Liveness probes restart unhealthy pods; readiness probes stop routing to pods that aren't ready. HPA scales pods based on metrics. You don't need to be a K8s expert, but understanding these concepts is essential.",
      },
      {
        name: "Observability & Monitoring",
        subtopics: [
          "Structured logging (pino/winston) with correlation IDs",
          "Distributed tracing (OpenTelemetry, Jaeger)",
          "Metrics: RED method (Rate, Errors, Duration) with Prometheus + Grafana",
          "APM tools (Datadog, New Relic) for production debugging",
          "Alerting strategies: avoid alert fatigue, actionable alerts only",
        ],
        theory: "Observability has three pillars: logs, traces, metrics. Structured JSON logs with correlation IDs let you trace a request across services. OpenTelemetry is the standard for distributed tracing â€” it instruments your code and exports spans to backends like Jaeger. The RED method (request Rate, Error rate, Duration) gives you the essential service health metrics. Instrument everything in production.",
      },
      {
        name: "Cloud Services (AWS Focus)",
        subtopics: [
          "Compute: EC2, ECS/Fargate, Lambda (serverless)",
          "Storage: S3, RDS, ElastiCache, DynamoDB",
          "Networking: VPC, ALB, Route53, CloudFront",
          "Infrastructure as Code: Terraform or AWS CDK",
          "Cost optimization strategies",
        ],
        theory: "Senior devs choose the right compute model: EC2 for full control, ECS/Fargate for containerized workloads without managing servers, Lambda for event-driven/sporadic workloads. Use RDS for managed Postgres (automated backups, replicas), ElastiCache for managed Redis. Infrastructure as Code (Terraform/CDK) ensures reproducible environments. Always design with VPC isolation and least-privilege IAM.",
      },
    ],
  },
  {
    id: "phase5",
    phase: "Phase 5",
    title: "Testing, Performance & Soft Skills",
    duration: "3â€“4 weeks",
    icon: "ðŸŽ¯",
    color: "#be123c",
    bgLight: "#fff1f2",
    topics: [
      {
        name: "Testing Strategy",
        subtopics: [
          "Testing pyramid: unit (70%) â†’ integration (20%) â†’ e2e (10%)",
          "Unit testing with Vitest/Jest, mocking strategies",
          "Integration tests: testcontainers for real DB/Redis in tests",
          "API testing: supertest for HTTP, contract testing (Pact)",
          "Load testing with k6 or Artillery",
        ],
        theory: "The testing pyramid guides investment: many fast unit tests, fewer integration tests, minimal e2e tests. Use testcontainers to spin up real Postgres/Redis in Docker for integration tests â€” no more mocking databases. Contract testing (Pact) verifies API contracts between services without running everything together. Load test before production to find bottlenecks.",
      },
      {
        name: "Performance Optimization",
        subtopics: [
          "Node.js profiling: --inspect, clinic.js, 0x flame graphs",
          "Memory leak detection: heapdump, --max-old-space-size",
          "Connection pooling, query optimization, N+1 detection",
          "Response compression, HTTP/2, keep-alive tuning",
          "Benchmarking with autocannon",
        ],
        theory: "Profile before optimizing. Clinic.js gives you flame graphs (CPU), bubbleprof (async), and heap profiler. Common Node.js perf issues: unhandled promise accumulation, synchronous operations blocking the event loop, missing DB indexes, N+1 queries. Use autocannon to benchmark endpoints and measure the impact of your optimizations.",
      },
      {
        name: "Code Quality & Architecture",
        subtopics: [
          "Clean Architecture / Hexagonal Architecture in Node.js",
          "SOLID principles applied to JavaScript/TypeScript",
          "TypeScript: advanced types, generics, utility types, discriminated unions",
          "Code review best practices: what to look for",
          "Technical documentation: ADRs (Architecture Decision Records)",
        ],
        theory: "Clean Architecture separates business logic from infrastructure (DB, HTTP, external APIs) using dependency inversion. Your core domain should have zero imports from Express, Prisma, or AWS SDK. TypeScript is non-negotiable for senior roles â€” master generics, conditional types, and discriminated unions. Write ADRs to document why you made architectural decisions.",
      },
      {
        name: "Senior-Level Soft Skills",
        subtopics: [
          "System design interviews: framework (requirements â†’ high-level â†’ deep dive â†’ tradeoffs)",
          "Technical leadership: mentoring, code reviews, RFC process",
          "Estimating and breaking down complex projects",
          "Communicating tradeoffs to non-technical stakeholders",
          "Incident response and postmortems (blameless culture)",
        ],
        theory: "Senior = technical depth + leadership. In system design interviews, always start with requirements (functional + non-functional), then high-level architecture, then deep dive into 1-2 components, always discussing tradeoffs. In your role, write RFCs for major changes, mentor juniors through pairing, lead blameless postmortems. The ability to communicate 'why' behind technical decisions is what makes you senior.",
      },
    ],
  },
];

const ProgressBar = ({ completed, total }) => {
  const pct = total > 0 ? (completed / total) * 100 : 0;
  return (
    <div style={{ display: "flex", alignItems: "center", gap: 8 }}>
      <div style={{ flex: 1, height: 6, background: "#e5e7eb", borderRadius: 3 }}>
        <div
          style={{
            width: `${pct}%`,
            height: "100%",
            background: pct === 100 ? "#10b981" : "#6366f1",
            borderRadius: 3,
            transition: "width 0.4s ease",
          }}
        />
      </div>
      <span style={{ fontSize: 12, color: "#6b7280", minWidth: 36, textAlign: "right" }}>
        {Math.round(pct)}%
      </span>
    </div>
  );
};

export default function SeniorNodeRoadmap() {
  const [expandedPhase, setExpandedPhase] = useState("phase1");
  const [expandedTopic, setExpandedTopic] = useState(null);
  const [completed, setCompleted] = useState({});

  const toggleTopic = (key) => {
    setExpandedTopic(expandedTopic === key ? null : key);
  };

  const toggleComplete = (key, e) => {
    e.stopPropagation();
    setCompleted((prev) => ({ ...prev, [key]: !prev[key] }));
  };

  const getPhaseProgress = (phase) => {
    let total = 0;
    let done = 0;
    phase.topics.forEach((topic, ti) => {
      topic.subtopics.forEach((_, si) => {
        total++;
        if (completed[`${phase.id}-${ti}-${si}`]) done++;
      });
    });
    return { total, done };
  };

  const overall = roadmapData.reduce(
    (acc, phase) => {
      const p = getPhaseProgress(phase);
      return { total: acc.total + p.total, done: acc.done + p.done };
    },
    { total: 0, done: 0 }
  );

  return (
    <div
      style={{
        minHeight: "100vh",
        background: "#fafaf9",
        fontFamily:
          "'SÃ¶hne', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif",
      }}
    >
      {/* Header */}
      <div
        style={{
          background: "linear-gradient(135deg, #1e1b4b 0%, #312e81 50%, #4c1d95 100%)",
          padding: "40px 24px 32px",
          color: "white",
        }}
      >
        <div style={{ maxWidth: 800, margin: "0 auto" }}>
          <div
            style={{
              fontSize: 11,
              textTransform: "uppercase",
              letterSpacing: 2,
              opacity: 0.7,
              marginBottom: 8,
            }}
          >
            Preparation Roadmap
          </div>
          <h1
            style={{
              fontSize: 28,
              fontWeight: 700,
              margin: "0 0 6px 0",
              letterSpacing: -0.5,
            }}
          >
            Senior Node.js Backend Developer
          </h1>
          <p style={{ fontSize: 14, opacity: 0.7, margin: "0 0 20px 0" }}>
            ~20â€“27 weeks â€¢ Theory-first approach â€¢ Intermediate â†’ Senior
          </p>

          <div
            style={{
              background: "rgba(255,255,255,0.1)",
              borderRadius: 10,
              padding: "14px 18px",
              backdropFilter: "blur(10px)",
            }}
          >
            <div
              style={{
                display: "flex",
                justifyContent: "space-between",
                marginBottom: 8,
                fontSize: 13,
              }}
            >
              <span style={{ opacity: 0.8 }}>Overall Progress</span>
              <span style={{ fontWeight: 600 }}>
                {overall.done}/{overall.total} topics
              </span>
            </div>
            <div style={{ height: 8, background: "rgba(255,255,255,0.15)", borderRadius: 4 }}>
              <div
                style={{
                  width: `${overall.total > 0 ? (overall.done / overall.total) * 100 : 0}%`,
                  height: "100%",
                  background: "linear-gradient(90deg, #a78bfa, #34d399)",
                  borderRadius: 4,
                  transition: "width 0.4s ease",
                }}
              />
            </div>
          </div>
        </div>
      </div>

      {/* Phases */}
      <div style={{ maxWidth: 800, margin: "0 auto", padding: "24px 16px 60px" }}>
        {roadmapData.map((phase) => {
          const isOpen = expandedPhase === phase.id;
          const progress = getPhaseProgress(phase);

          return (
            <div
              key={phase.id}
              style={{
                marginBottom: 16,
                borderRadius: 12,
                border: isOpen ? `2px solid ${phase.color}22` : "2px solid transparent",
                background: "white",
                boxShadow: isOpen
                  ? "0 4px 24px rgba(0,0,0,0.08)"
                  : "0 1px 4px rgba(0,0,0,0.04)",
                transition: "all 0.2s ease",
                overflow: "hidden",
              }}
            >
              {/* Phase Header */}
              <div
                onClick={() => setExpandedPhase(isOpen ? null : phase.id)}
                style={{
                  padding: "18px 20px",
                  cursor: "pointer",
                  display: "flex",
                  alignItems: "center",
                  gap: 14,
                  userSelect: "none",
                }}
              >
                <div
                  style={{
                    width: 44,
                    height: 44,
                    borderRadius: 10,
                    background: phase.bgLight,
                    display: "flex",
                    alignItems: "center",
                    justifyContent: "center",
                    fontSize: 22,
                    flexShrink: 0,
                  }}
                >
                  {phase.icon}
                </div>
                <div style={{ flex: 1, minWidth: 0 }}>
                  <div style={{ display: "flex", alignItems: "center", gap: 8, marginBottom: 2 }}>
                    <span
                      style={{
                        fontSize: 10,
                        textTransform: "uppercase",
                        letterSpacing: 1.5,
                        color: phase.color,
                        fontWeight: 700,
                      }}
                    >
                      {phase.phase}
                    </span>
                    <span style={{ fontSize: 11, color: "#9ca3af" }}>â€¢ {phase.duration}</span>
                  </div>
                  <div style={{ fontSize: 16, fontWeight: 600, color: "#111827" }}>
                    {phase.title}
                  </div>
                  <div style={{ marginTop: 6, maxWidth: 300 }}>
                    <ProgressBar completed={progress.done} total={progress.total} />
                  </div>
                </div>
                <div
                  style={{
                    fontSize: 18,
                    color: "#9ca3af",
                    transform: isOpen ? "rotate(180deg)" : "rotate(0deg)",
                    transition: "transform 0.2s ease",
                  }}
                >
                  â–¾
                </div>
              </div>

              {/* Topics */}
              {isOpen && (
                <div style={{ padding: "0 20px 20px" }}>
                  {phase.topics.map((topic, ti) => {
                    const topicKey = `${phase.id}-t${ti}`;
                    const isTopicOpen = expandedTopic === topicKey;
                    const topicDone = topic.subtopics.filter(
                      (_, si) => completed[`${phase.id}-${ti}-${si}`]
                    ).length;

                    return (
                      <div
                        key={ti}
                        style={{
                          borderRadius: 10,
                          border: "1px solid #f3f4f6",
                          marginBottom: 10,
                          background: isTopicOpen ? phase.bgLight : "#fafafa",
                          transition: "background 0.2s ease",
                        }}
                      >
                        <div
                          onClick={() => toggleTopic(topicKey)}
                          style={{
                            padding: "14px 16px",
                            cursor: "pointer",
                            display: "flex",
                            alignItems: "center",
                            gap: 10,
                            userSelect: "none",
                          }}
                        >
                          <div
                            style={{
                              width: 8,
                              height: 8,
                              borderRadius: "50%",
                              background:
                                topicDone === topic.subtopics.length
                                  ? "#10b981"
                                  : topicDone > 0
                                  ? "#f59e0b"
                                  : "#d1d5db",
                              flexShrink: 0,
                            }}
                          />
                          <span
                            style={{
                              flex: 1,
                              fontWeight: 500,
                              fontSize: 14,
                              color: "#1f2937",
                            }}
                          >
                            {topic.name}
                          </span>
                          <span style={{ fontSize: 11, color: "#9ca3af" }}>
                            {topicDone}/{topic.subtopics.length}
                          </span>
                          <span
                            style={{
                              fontSize: 14,
                              color: "#9ca3af",
                              transform: isTopicOpen ? "rotate(90deg)" : "rotate(0deg)",
                              transition: "transform 0.2s ease",
                            }}
                          >
                            â€º
                          </span>
                        </div>

                        {isTopicOpen && (
                          <div style={{ padding: "0 16px 14px" }}>
                            {/* Theory box */}
                            <div
                              style={{
                                background: "white",
                                border: `1px solid ${phase.color}22`,
                                borderLeft: `3px solid ${phase.color}`,
                                borderRadius: 8,
                                padding: "12px 14px",
                                marginBottom: 12,
                                fontSize: 13,
                                lineHeight: 1.65,
                                color: "#374151",
                              }}
                            >
                              <div
                                style={{
                                  fontSize: 10,
                                  textTransform: "uppercase",
                                  letterSpacing: 1.5,
                                  color: phase.color,
                                  fontWeight: 700,
                                  marginBottom: 6,
                                }}
                              >
                                Theory
                              </div>
                              {topic.theory}
                            </div>

                            {/* Subtopics checklist */}
                            <div style={{ display: "flex", flexDirection: "column", gap: 6 }}>
                              {topic.subtopics.map((sub, si) => {
                                const key = `${phase.id}-${ti}-${si}`;
                                const isDone = completed[key];
                                return (
                                  <label
                                    key={si}
                                    onClick={(e) => toggleComplete(key, e)}
                                    style={{
                                      display: "flex",
                                      alignItems: "flex-start",
                                      gap: 10,
                                      padding: "6px 8px",
                                      borderRadius: 6,
                                      cursor: "pointer",
                                      background: isDone ? "#f0fdf4" : "transparent",
                                      transition: "background 0.15s ease",
                                    }}
                                  >
                                    <div
                                      style={{
                                        width: 18,
                                        height: 18,
                                        borderRadius: 4,
                                        border: isDone
                                          ? "2px solid #10b981"
                                          : "2px solid #d1d5db",
                                        background: isDone ? "#10b981" : "white",
                                        display: "flex",
                                        alignItems: "center",
                                        justifyContent: "center",
                                        flexShrink: 0,
                                        marginTop: 1,
                                        transition: "all 0.15s ease",
                                        color: "white",
                                        fontSize: 11,
                                        fontWeight: 700,
                                      }}
                                    >
                                      {isDone ? "âœ“" : ""}
                                    </div>
                                    <span
                                      style={{
                                        fontSize: 13,
                                        color: isDone ? "#6b7280" : "#374151",
                                        textDecoration: isDone ? "line-through" : "none",
                                        lineHeight: 1.5,
                                      }}
                                    >
                                      {sub}
                                    </span>
                                  </label>
                                );
                              })}
                            </div>
                          </div>
                        )}
                      </div>
                    );
                  })}
                </div>
              )}
            </div>
          );
        })}

        {/* Footer tip */}
        <div
          style={{
            marginTop: 24,
            padding: "16px 20px",
            background: "#f8fafc",
            borderRadius: 10,
            border: "1px solid #e2e8f0",
            fontSize: 13,
            color: "#64748b",
            lineHeight: 1.6,
          }}
        >
          <strong style={{ color: "#334155" }}>ðŸ’¡ How to use this roadmap:</strong> Expand
          each phase and topic to read the theory. Check off subtopics as you learn them.
          Ask me to deep-dive into any specific topic â€” I'll explain the theory in detail
          with code examples.
        </div>
      </div>
    </div>
  );
}

    // Example ending:
    ReactDOM.createRoot(document.getElementById("root"))
      .render(<SeniorNodeRoadmap />);
  </script>
</body>
</html>
